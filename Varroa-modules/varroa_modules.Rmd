```{load libraries}
#load library
library(dplyr)
library(tidyverse)
library(vegan)
library(DESeq2)
library(ggfortify)

```


 בקובץ של תכונות של הוירוסים שמעניינים אותי. "ClinicalTraits.csv" לעשות כאן סדר!  להחליף את הקובץ 
```{Load trait data}
traitData = read.csv("ClinicalTraits.csv");
dim(traitData)
names(traitData)

# remove columns that hold information we do not need.
allTraits = traitData[, -c(31, 16)];
allTraits = allTraits[, c(2, 11:36) ];
dim(allTraits)
names(allTraits)

# Form a data frame analogous to expression data that will hold the clinical traits.

femaleSamples = rownames(datExpr);
traitRows = match(femaleSamples, allTraits$Mice);
datTraits = allTraits[traitRows, -1];
rownames(datTraits) = allTraits[traitRows, 1];

collectGarbage();
```

להמשיך מכאן לפי סעעיף



```{import and join varroa and virus data}
#import the varroa transcripts ("target_id") and their corresponding gene ("gene_id"). and add a col names.
varroa_isoforms <- read_tsv("/Users/nuriteliash/Documents/GitHub/varroa-virus-networks/data/gene2isoform.txt.gz", col_names = c("gene_id", "target_id"))

#import the SRR libraries with tpms
df <- read_rds("./data/kallisto.rds")

#join the varroa trascnripts(varroa_isoforms), and the library tpm (df), by the varroa genes ("traget_id")
gene_tpm <-  left_join(varroa_isoforms, df, by = "target_id")

#collapse isoforms to a single row of a gene, and sum the tpm(s) per gene per library
gene_tpm_collps <- gene_tpm %>% gather("library","tpm", -target_id, -gene_id) %>%
  group_by(gene_id, library) %>% summarise(gene_tpm = sum(tpm))


# spread the table again, by library
final_gene_tpm <- spread(gene_tpm_collps, key = "library", value = "gene_tpm") %>% column_to_rownames('gene_id')
```

```{PCA libraries by gene}
#transpose final_gene_tpm, and transform (log10+0.000001) 
final_gene_tpm_T<- transposeBigData(log10(final_gene_tpm + 0.000001))

#plot PCA, detect outlier libraries
autoplot(prcomp(final_gene_tpm_T), label = TRUE)

#remove outlier libraries (by col)
for_modules <- final_gene_tpm %>% select(-c("SRR5109825", "SRR5109827", "SRR533974" , "SRR3927496", "SRR8867385")) %>%
   transposeBigData() 

#plot PCA - the reduced file
autoplot(prcomp(transposeBigData(log10(for_modules + 0.000001))), label = TRUE)
```


***optional:
```{PCA libraries by isoform}
#transpose final_gene_tpm, and transform 
gene_tpm_T <- gene_tpm %>% 
  select(-"gene_id") %>%
  column_to_rownames("target_id") %>% 
  transposeBigData() 
  
#plot PCA, detect outliers
autoplot(prcomp(log10(gene_tpm_T + 0.000001)), label = TRUE)

# log10 transform
isoform_modules <- log10(gene_tpm_T + 0.000001)

```


now the table is ready for varroa module making!

#following the 2.a step in WGCNA tutorial: "Automatic, one-step network construction and module detection"
```{WGCNA set directory and library}
#=====================================================================================
#
#  Code chunk 1
#
#=====================================================================================

# If necessary, change the path below to the directory where the data files are stored.
setwd("/Users/nuriteliash/Documents/GitHub/varroa-virus-networks")
# Display the current working directory
getwd()

# Load the WGCNA package
library(WGCNA)

# Allow multi-threading within WGCNA. This helps speed up certain calculations.
options(stringsAsFactors = FALSE)

```

```{WGCNA 2a automatic}
#=====================================================================================
#
#  Code chunk 2
#
#=====================================================================================

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=25, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(for_modules, powerVector = powers, verbose = 5)
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.80,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
```

Constructing the gene network and identifying modules is now a simple function call:
```{WGCNA 2.a.2 automatic}
#=====================================================================================
#
#  Code chunk 3 - automatic!
#
#=====================================================================================

net = blockwiseModules(for_modules, power = 10,
                       TOMType = "unsigned", minModuleSize = 30,
                       reassignThreshold = 0, mergeCutHeight = 0.25,
                       numericLabels = TRUE, pamRespectsDendro = FALSE,
                       saveTOMs = TRUE,
                       saveTOMFileBase = "Varroa_modulesTOM", 
                       verbose = 3)
```

```{WGCNA 2a automatic}
#=====================================================================================
#
#  Code chunk 4 - automatic!
#
#=====================================================================================

# open a graphics window
sizeGrWindow(12, 9)
# Convert labels to colors for plotting
mergedColors = labels2colors(net$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(net$dendrograms[[1]], mergedColors[net$blockGenes[[1]]],
                    "Module colors",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
```

save the module assignment and module eigengene information necessary for subsequent analysis:
```{WGCNA 2a automatic}
#=====================================================================================
#
#  Code chunk 5
#
#=====================================================================================

moduleLabels = net$colors
moduleColors = labels2colors(net$colors)
MEs = net$MEs;
geneTree = net$dendrograms[[1]];
save(MEs, moduleLabels, moduleColors, geneTree, 
     file = "Varroa_modules_networkConstruction-auto.RData")
```

Relating modules to external information and identifying important
genes
```{WGCNA 3.a Quantifying module–trait associations}
#=====================================================================================
#
#  Code chunk 2
#
#=====================================================================================

lnames = load("Varroa_modules_networkConstruction-auto.RData")
lnames
# Rename variables to avoid conflicts
femaleLabels = moduleLabels;
femaleColors = moduleColors;
femaleTree = geneTree;
femaleMEs = orderMEs(MEs, greyName = "ME0");
```

```{WGCNA 3 Relating consensus modules to female set-specific modules}
#=====================================================================================
#
#  Code chunk 3
#
#=====================================================================================


lnames = load("Varroa_modules_networkConstruction-auto.RData")
lnames
```

```{WGCNA 3 Relating consensus modules to female set-specific modules}
#=====================================================================================
#
#  Code chunk 4
#
#=====================================================================================


# Isolate the module labels in the order they appear in ordered module eigengenes
femModuleLabels = substring(names(femaleMEs), 3)
consModuleLabels = substring(names(consMEs[[1]]$data), 3)
# Convert the numeric module labels to color labels
femModules = labels2colors(as.numeric(femModuleLabels))
consModules = labels2colors(as.numeric(consModuleLabels))
# Numbers of female and consensus modules
nFemMods = length(femModules)
nConsMods = length(consModules)
# Initialize tables of p-values and of the corresponding counts
pTable = matrix(0, nrow = nFemMods, ncol = nConsMods);
CountTbl = matrix(0, nrow = nFemMods, ncol = nConsMods);
# Execute all pairwaise comparisons
for (fmod in 1:nFemMods)
  for (cmod in 1:nConsMods)
  {
    femMembers = (femaleColors == femModules[fmod]);
    consMembers = (moduleColors == consModules[cmod]);
    pTable[fmod, cmod] = -log10(fisher.test(femMembers, consMembers, alternative = "greater")$p.value);
    CountTbl[fmod, cmod] = sum(femaleColors == femModules[fmod] & moduleColors ==
                      consModules[cmod])
  }

```

